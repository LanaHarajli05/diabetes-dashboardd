# -*- coding: utf-8 -*-
"""app_py.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nh0t9-PVIWkN1ofpiMf3_CpM_zQUIi_T
"""

from google.colab import drive
import os

# Mount Google Drive to store the file
drive.mount('/content/drive')

# Define path to save Streamlit app
app_path = "/content/drive/MyDrive/diabetes_dashboard/app.py"
os.makedirs(os.path.dirname(app_path), exist_ok=True)

# Streamlit code template with 1 chart
code = '''
import streamlit as st
import pandas as pd
import plotly.express as px

# Load data
df = pd.read_csv("diabetes_clean.csv")

# Sidebar filters
st.sidebar.title("Filters")
gender_filter = st.sidebar.multiselect("Select Gender", options=df["gender"].unique(), default=df["gender"].unique())
age_group_filter = st.sidebar.multiselect("Select Age Group", options=df["age_group"].unique(), default=df["age_group"].unique())
smoking_filter = st.sidebar.multiselect("Select Smoking History", options=df["smoking_history"].unique(), default=df["smoking_history"].unique())

# Filter data
filtered_df = df[
    (df["gender"].isin(gender_filter)) &
    (df["age_group"].isin(age_group_filter)) &
    (df["smoking_history"].isin(smoking_filter))
]

# Title
st.title("ü©∫ Diabetes Analytics Dashboard")
st.markdown("Analyze diabetes trends by demographic and health factors.")

# Layout: 1st row with 3 columns
col1, col2, col3 = st.columns(3)

# Chart 1: Diabetes by Age Group
with col1:
    age_group_chart = filtered_df.groupby("age_group")["diabetes"].mean().reset_index()
    fig = px.bar(age_group_chart, x="age_group", y="diabetes",
                 labels={"diabetes": "Diabetes Rate", "age_group": "Age Group"},
                 title="Diabetes Prevalence by Age Group")
    st.plotly_chart(fig, use_container_width=True)
'''

# Write the app.py file
with open(app_path, "w") as f:
    f.write(code)

print("‚úÖ app.py created at:", app_path)

!ngrok config add-authtoken "2ygLGeaxapWfrJZC0rS70Ev35Om_tcQv9zLBuakfsm1AmHrN"

!rm -rf ~/.ngrok2

!ngrok config add-authtoken "2ygLGeaxapWfrJZC0rS70Ev35Om_tcQv9zLBuakfsm1AmHrN"

from google.colab import drive
drive.mount('/content/drive')

!ngrok config add-authtoken "2ygLGeaxapWfrJZC0rS70Ev35Om_tcQv9zLBuakfsm1AmHrN"

from pyngrok import ngrok

# Kill any prior tunnel sessions
ngrok.kill()

# Start Streamlit
!streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &>/content/log.txt &

# Create public tunnel
url = ngrok.connect(8501)
print("üåê Open your dashboard here:", url)

from google.colab import files
uploaded = files.upload()

import shutil

# Move uploaded file to your Streamlit app directory
shutil.copy('/content/diabetes_clean.csv', '/content/drive/MyDrive/diabetes_dashboard/diabetes_clean.csv')

print("‚úÖ File moved successfully.")

from pyngrok import ngrok
ngrok.kill()
!streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &>/content/log.txt &
url = ngrok.connect(8501)
print("üåê Dashboard URL:", url)

from pyngrok import ngrok
import os
import time
from IPython import get_ipython # Import get_ipython

# Kill any prior pyngrok tunnels (this is a good practice)
print("Attempting to kill tunnels started by pyngrok...")
ngrok.kill()
print("pyngrok tunnels killed.")

# **Crucially**, stop all ngrok processes explicitly using pkill -f
# -f is used to force kill if necessary and search based on full command line
# Use get_ipython().system() for reliable shell command execution in Colab
print("Attempting to kill all ngrok processes forcefully...")
get_ipython().system('pkill -f ngrok')

# Give ample time for processes to terminate
# This sleep is very important after pkill to ensure resources are freed
print("Waiting for ngrok processes to terminate...")
time.sleep(15) # Increased sleep time for robustness

print("Checking if ngrok processes are still running...")
# Check for running ngrok processes (should ideally show nothing)
get_ipython().system('pgrep ngrok') # This command will print PIDs if processes are running

# Ensure the log file is cleared or doesn't contain previous runs
log_file_path = '/content/log.txt'
if os.path.exists(log_file_path):
    os.remove(log_file_path)
    print(f"Cleared log file: {log_file_path}")
else:
    print(f"Log file not found: {log_file_path}")


# Start Streamlit in the background, redirecting output to a log file
# Use nohup to ensure it keeps running even if the notebook disconnects
print("Starting Streamlit...")
# Streamlit starts its own ngrok agent if it detects an internet connection
# and you have `ngrok` installed and configured. Running it with `&` or `nohup &`
# puts it in the background.
streamlit_command = f'nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &> {log_file_path} &'

# Use get_ipython().system() for running shell commands reliably in Colab
streamlit_process_status = get_ipython().system(streamlit_command)
print(f"Streamlit command executed: {streamlit_command}")
# 0 usually means command was sent successfully, check log for Streamlit errors


# Give Streamlit and its potential ngrok agent time to initialize
# This sleep is crucial to allow the Streamlit app to start and the ngrok agent
# it might launch to become ready. Increased sleep time to 25 seconds for more
# complex apps or environments with potential delays.
print("Waiting for Streamlit and ngrok agent to start...")
time.sleep(25)

# Create public tunnel
# pyngrok.connect(8501) will attempt to connect to the ngrok agent running on
# the machine (which should be the one started by Streamlit/nohup or implicitly by pyngrok).
try:
    print("Attempting to connect to ngrok tunnel...")
    # Connect to the standard ngrok agent API port
    url = ngrok.connect(8501)
    print("üåê Dashboard URL:", url)
except Exception as e:
    # If connection fails, print the error and check the log file
    print(f"Error connecting ngrok: {e}")
    print("\nChecking log file for Streamlit or ngrok agent errors:")
    if os.path.exists(log_file_path):
        with open(log_file_path, 'r') as f:
            print(f.read())
    else:
        print("Log file not found.")

print("\nScript finished.")

from pyngrok import ngrok
import os
import time

# Kill any prior pyngrok tunnels (this is a good practice)
ngrok.kill()

# **NEW:** Stop all ngrok processes explicitly using pkill.
# This is important in a notebook environment to clean up previous runs.
!pkill ngrok

# Give a moment for processes to stop
time.sleep(5) # Increased sleep time for better robustness

# Ensure the log file is cleared or doesn't contain previous runs
log_file_path = '/content/log.txt'
if os.path.exists(log_file_path):
    os.remove(log_file_path)

# Start Streamlit
# Use nohup to ensure streamlit keeps running even if the notebook disconnects
# Redirect output to log file
# Use os.system or subprocess for better control, but the ! method is fine here
# Adding &> redirects both stdout and stderr
# The '&' at the end runs it in the background
streamlit_process = os.system(f'nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &> {log_file_path} &')

# Give Streamlit and ngrok a moment to start before connecting ngrok
# Increased sleep time significantly to allow Streamlit and its ngrok agent time to initialize
time.sleep(15) # Adjust sleep time if needed based on observation

# Create public tunnel
# Check log file for Streamlit startup errors if connection fails
try:
    url = ngrok.connect(8501)
    print("üåê Dashboard URL:", url)
except Exception as e:
    print(f"Error connecting ngrok: {e}")
    print("Checking log file for Streamlit errors:")
    if os.path.exists(log_file_path):
        with open(log_file_path, 'r') as f:
            print(f.read())
    else:
        print("Log file not found.")

from google.colab import drive
drive.mount('/content/drive')

!ngrok config add-authtoken "2ygLGeaxapWfrJZC0rS70Ev35Om_tcQv9zLBuakfsm1AmHrN"

from pyngrok import ngrok
import os
import time

# Kill any prior tunnel sessions
ngrok.kill()

# Ensure the log file is cleared or doesn't contain previous runs
log_file_path = '/content/log.txt'
if os.path.exists(log_file_path):
    os.remove(log_file_path)

# Start Streamlit
# Use nohup to ensure streamlit keeps running even if the notebook disconnects
# Redirect output to log file
streamlit_process = os.system(f'nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &> {log_file_path} &')

# Give Streamlit a moment to start before connecting ngrok
time.sleep(5) # Adjust sleep time if needed

# Create public tunnel
# Check log file for Streamlit startup errors if connection fails
url = ngrok.connect(8501)
print("üåê Dashboard URL:", url)

# Optional: Check the log file for Streamlit errors if the tunnel doesn't work
# !cat /content/log.txt

from pyngrok import ngrok
import os
import time

# Kill any prior pyngrok tunnels (this is a good practice)
ngrok.kill()

# **NEW:** Stop all ngrok processes explicitly
!pkill ngrok

# Give a moment for processes to stop
time.sleep(2)

# Ensure the log file is cleared or doesn't contain previous runs
log_file_path = '/content/log.txt'
if os.path.exists(log_file_path):
    os.remove(log_file_path)

# Start Streamlit
# Use nohup to ensure streamlit keeps running even if the notebook disconnects
# Redirect output to log file
streamlit_process = os.system(f'nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &> {log_file_path} &')

# Give Streamlit a moment to start before connecting ngrok
# Increased sleep time slightly for more robustness
time.sleep(10)

# Create public tunnel
# Check log file for Streamlit startup errors if connection fails
url = ngrok.connect(8501)
print("üåê Dashboard URL:", url)

# Optional: Check the log file for Streamlit errors if the tunnel doesn't work
# !cat /content/log.txt

from pyngrok import ngrok
import os
import time

# Kill any prior pyngrok tunnels (this is a good practice)
ngrok.kill()

# **NEW:** Stop all ngrok processes explicitly
!pkill ngrok

# Give a moment for processes to stop
time.sleep(2)

# Ensure the log file is cleared or doesn't contain previous runs
log_file_path = '/content/log.txt'
if os.path.exists(log_file_path):
    os.remove(log_file_path)

# Start Streamlit
# Use nohup to ensure streamlit keeps running even if the notebook disconnects
# Redirect output to log file
streamlit_process = os.system(f'nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &> {log_file_path} &')

# Give Streamlit a moment to start before connecting ngrok
# Increased sleep time slightly for more robustness
time.sleep(10)

# Create public tunnel
# Check log file for Streamlit startup errors if connection fails
url = ngrok.connect(8501)
print("üåê Dashboard URL:", url)

# Optional: Check the log file for Streamlit errors if the tunnel doesn't work
# !cat /content/log.txt

# Re-mount Google Drive
from google.colab import drive
drive.mount('/content/drive')

# Re-add your Ngrok auth token
!ngrok config add-authtoken "2ygLGeaxapWfrJZC0rS70Ev35Om_tcQv9zLBuakfsm1AmHrN"

from pyngrok import ngrok
ngrok.kill()

!streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &>/content/log.txt &

url = ngrok.connect(8501)
print("üåê Dashboard URL:", url)

from pyngrok import ngrok
import os
import time
from IPython import get_ipython # Import get_ipython

# Kill any prior pyngrok tunnels
ngrok.kill()

# **NEW:** Stop all ngrok processes explicitly using pkill -f
# -f is used to force kill if necessary and search based on full command line
print("Attempting to kill all ngrok processes...")
!pkill -f ngrok
# Give ample time for processes to terminate
time.sleep(10) # Increased sleep time for robustness

print("Checking if ngrok processes are still running...")
!pgrep ngrok # Check for running ngrok processes (should ideally show nothing)

# Ensure the log file is cleared or doesn't contain previous runs
log_file_path = '/content/log.txt'
if os.path.exists(log_file_path):
    os.remove(log_file_path)
    print(f"Cleared log file: {log_file_path}")
else:
    print(f"Log file not found: {log_file_path}")


# Start Streamlit in the background, redirecting output to a log file
# Use nohup to ensure it keeps running even if the notebook disconnects
print("Starting Streamlit...")
streamlit_command = f'nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &> {log_file_path} &'

# Use get_ipython().system() for running shell commands reliably in Colab
streamlit_process_status = get_ipython().system(streamlit_command)
print(f"Streamlit command executed: {streamlit_command}")
print(f"Streamlit process status: {streamlit_process_status}") # 0 usually means command was sent successfully

# Give Streamlit and its potential ngrok agent time to initialize
# This sleep is crucial to allow the Streamlit app to start and the ngrok agent
# it might launch (or the agent started by pyngrok implicitly) to become ready.
print("Waiting for Streamlit and ngrok agent to start...")
time.sleep(20) # Further increased sleep time

# Create public tunnel
# pyngrok.connect(8501) will attempt to connect to the ngrok agent running on
# the machine (which should be the one started by Streamlit/nohup or implicitly by pyngrok).
try:
    print("Attempting to connect to ngrok tunnel...")
    # Connect to the standard ngrok agent API port
    url = ngrok.connect(8501)
    print("üåê Dashboard URL:", url)
except Exception as e:
    # If connection fails, print the error and check the log file
    print(f"Error connecting ngrok: {e}")
    print("\nChecking log file for Streamlit or ngrok agent errors:")
    if os.path.exists(log_file_path):
        with open(log_file_path, 'r') as f:
            print(f.read())
    else:
        print("Log file not found.")

print("\nScript finished.")

from pyngrok import ngrok
import os
import time

# Kill any prior pyngrok tunnels (this is a good practice)
ngrok.kill()

# **NEW:** Stop all ngrok processes explicitly
# Use -f to force kill if necessary, though use with caution
!pkill -f ngrok

# Give a moment for processes to stop
# Increased sleep time to ensure processes are fully terminated
time.sleep(5)

# Ensure the log file is cleared or doesn't contain previous runs
log_file_path = '/content/log.txt'
if os.path.exists(log_file_path):
    os.remove(log_file_path)

# Start Streamlit
# Use nohup to ensure streamlit keeps running even if the notebook disconnects
# Redirect output to log file
streamlit_process = os.system(f'nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &> {log_file_path} &')

# Give Streamlit and ngrok a moment to start before connecting ngrok
# Increased sleep time significantly to allow Streamlit and its ngrok agent time to initialize
time.sleep(15) # Adjust sleep time if needed based on observation

# Create public tunnel
# Check log file for Streamlit startup errors if connection fails
try:
    # Attempt to connect to the ngrok agent started by Streamlit
    url = ngrok.connect(8501)
    print("üåê Dashboard URL:", url)
except Exception as e:
    # If connection fails, print the error and check the log file
    print(f"Error connecting ngrok: {e}")
    print("Checking log file for Streamlit errors:")
    if os.path.exists(log_file_path):
        with open(log_file_path, 'r') as f:
            print(f.read())
    else:
        print("Log file not found.")

# Optional: Check the log file for Streamlit errors if the tunnel doesn't work
# Uncomment the line below after running if you suspect Streamlit failed to start
# !cat /content/log.txt

from pyngrok import ngrok
ngrok.kill()
!streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &>/content/log.txt &
url = ngrok.connect(8501)
print("üåê Dashboard URL:", url)

from pyngrok import ngrok
import os
import time
from IPython import get_ipython

# Kill any prior pyngrok tunnels
ngrok.kill()

# **NEW:** Stop all ngrok processes explicitly using pkill -f
# -f is used to force kill if necessary and search based on full command line
print("Attempting to kill all ngrok processes...")
# Use get_ipython().system() for reliable shell command execution in Colab
get_ipython().system('pkill -f ngrok')

# Give ample time for processes to terminate
# Increased sleep time for robustness
time.sleep(15)

print("Checking if ngrok processes are still running...")
# Check for running ngrok processes (should ideally show nothing)
get_ipython().system('pgrep ngrok')


# Ensure the log file is cleared or doesn't contain previous runs
log_file_path = '/content/log.txt'
if os.path.exists(log_file_path):
    os.remove(log_file_path)
    print(f"Cleared log file: {log_file_path}")
else:
    print(f"Log file not found: {log_file_path}")


# Start Streamlit in the background, redirecting output to a log file
# Use nohup to ensure it keeps running even if the notebook disconnects
print("Starting Streamlit...")
streamlit_command = f'nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &> {log_file_path} &'

# Use get_ipython().system() for running shell commands reliably in Colab
streamlit_process_status = get_ipython().system(streamlit_command)
print(f"Streamlit command executed: {streamlit_command}")
# 0 usually means command was sent successfully, check log for Streamlit errors


# Give Streamlit and its potential ngrok agent time to initialize
# This sleep is crucial to allow the Streamlit app to start and the ngrok agent
# it might launch (or the agent started by pyngrok implicitly) to become ready.
print("Waiting for Streamlit and ngrok agent to start...")
# Further increased sleep time to 25 seconds for more complex apps/startup
time.sleep(25)

# Create public tunnel
# pyngrok.connect(8501) will attempt to connect to the ngrok agent running on
# the machine (which should be the one started by Streamlit/nohup or implicitly by pyngrok).
try:
    print("Attempting to connect to ngrok tunnel...")
    # Connect to the standard ngrok agent API port
    url = ngrok.connect(8501)
    print("üåê Dashboard URL:", url)
except Exception as e:
    # If connection fails, print the error and check the log file
    print(f"Error connecting ngrok: {e}")
    print("\nChecking log file for Streamlit or ngrok agent errors:")
    if os.path.exists(log_file_path):
        with open(log_file_path, 'r') as f:
            print(f.read())
    else:
        print("Log file not found.")

print("\nScript finished.")

from google.colab import files
files.upload()  # Upload diabetes_clean.csv manually here

import shutil

# Adjust if needed ‚Äî this assumes the file is in /content/ now
shutil.copy("/content/diabetes_clean.csv", "/content/drive/MyDrive/diabetes_dashboard/diabetes_clean.csv")

from pyngrok import ngrok
ngrok.kill()
!streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &>/content/log.txt &
url = ngrok.connect(8501)
print("üåê Dashboard URL:", url)

from pyngrok import ngrok
import os
import time
from IPython import get_ipython

# Kill any prior pyngrok tunnels (good practice, though pkill is more forceful)
ngrok.kill()

# Stop all ngrok processes explicitly using pkill -f
# This is crucial to ensure no old ngrok agents are running
print("Attempting to kill all ngrok processes...")
# Use get_ipython().system() for reliable shell command execution in Colab
get_ipython().system('pkill -f ngrok')

# Give ample time for processes to terminate
# Increased sleep time for robustness
print("Waiting for ngrok processes to terminate...")
time.sleep(15) # Increased sleep time

print("Checking if ngrok processes are still running...")
# Check for running ngrok processes (should ideally show nothing)
get_ipython().system('pgrep ngrok')


# Ensure the log file is cleared or doesn't contain previous runs
log_file_path = '/content/log.txt'
if os.path.exists(log_file_path):
    os.remove(log_file_path)
    print(f"Cleared log file: {log_file_path}")
else:
    print(f"Log file not found: {log_file_path}")


# Start Streamlit in the background using nohup and redirect output
# Streamlit may start its own ngrok agent. This command starts Streamlit.
print("Starting Streamlit...")
streamlit_command = f'nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &> {log_file_path} &'

# Use get_ipython().system() for running shell commands reliably in Colab
# This command just *starts* the process, it doesn't wait for it.
streamlit_process_status = get_ipython().system(streamlit_command)
print(f"Streamlit command executed: {streamlit_command}")
# 0 usually means command was sent successfully, check log for Streamlit errors


# Give Streamlit and its potential ngrok agent time to initialize
# This sleep is CRUCIAL. Streamlit needs time to start and potentially
# launch its own ngrok agent before pyngrok can connect to it.
# Increased sleep time significantly for more complex apps/environments.
print("Waiting for Streamlit and ngrok agent to start...")
time.sleep(30) # Increased sleep time - adjust if needed

# Create public tunnel by *connecting* to the ngrok agent that Streamlit started.
# pyngrok.connect() will attempt to connect to the ngrok agent running on
# the machine (which should be the one started by Streamlit/nohup).
try:
    print("Attempting to connect to ngrok tunnel...")
    # Connect to the standard ngrok agent API port (default is 4040)
    # If Streamlit is running on 8501 and starts an ngrok agent, pyngrok
    # connects to the agent's API (usually 4040), not the streamlit port (8501).
    # However, ngrok.connect(8501) tells the *existing* agent to open a tunnel
    # to local port 8501.
    url = ngrok.connect(8501) # Specify the local port Streamlit is using
    print("üåê Dashboard URL:", url)
except Exception as e:
    # If connection fails, print the error and check the log file
    print(f"Error connecting ngrok: {e}")
    print("\nChecking log file for Streamlit or ngrok agent errors:")
    if os.path.exists(log_file_path):
        with open(log_file_path, 'r') as f:
            print(f.read())
    else:
        print("Log file not found.")

print("\nScript finished.")

from pyngrok import ngrok
import os
import time

# Kill any prior pyngrok tunnels (this is a good practice)
ngrok.kill()

# Stop all ngrok processes explicitly and force kill if necessary
# Increased sleep time to ensure processes are fully terminated
print("Attempting to kill all ngrok processes...")
!pkill -f ngrok
time.sleep(10) # Increased sleep time

print("Checking if ngrok processes are still running...")
!pgrep ngrok # Check for running ngrok processes

# Ensure the log file is cleared or doesn't contain previous runs
log_file_path = '/content/log.txt'
if os.path.exists(log_file_path):
    os.remove(log_file_path)
    print(f"Cleared log file: {log_file_path}")


# Start Streamlit in the background, redirecting output to a log file
# Use nohup to ensure it keeps running even if the notebook disconnects
print("Starting Streamlit...")
streamlit_command = f'nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &> {log_file_path} &'
streamlit_process = os.system(streamlit_command)
print(f"Streamlit command executed: {streamlit_command}")
print(f"Streamlit process exit code: {streamlit_process}") # 0 usually means success

# Give Streamlit and its ngrok agent a moment to start before connecting
# Increased sleep time significantly to allow Streamlit and its ngrok agent time to initialize
print("Waiting for Streamlit and ngrok agent to start...")
time.sleep(20) # Adjusted sleep time based on observation and potential startup delays

# Create public tunnel by connecting to the ngrok agent started by Streamlit
# Check log file for Streamlit startup errors if connection fails
try:
    print("Attempting to connect to ngrok tunnel...")
    # Use the connect method without additional parameters, assuming Streamlit started the agent on 8501
    url = ngrok.connect(8501)
    print("üåê Dashboard URL:", url)
except Exception as e:
    # If connection fails, print the error and check the log file
    print(f"Error connecting ngrok: {e}")
    print("\nChecking log file for Streamlit or ngrok agent errors:")
    if os.path.exists(log_file_path):
        with open(log_file_path, 'r') as f:
            print(f.read())
    else:
        print("Log file not found.")

print("\nScript finished.")

from pyngrok import ngrok
ngrok.kill()

!streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &>/content/log.txt &
url = ngrok.connect(8501)
print("üåê Dashboard URL:", url)

from pyngrok import ngrok
import os
import time
from IPython import get_ipython

# Kill any prior pyngrok tunnels (good practice, though pkill is more forceful)
# This cleans up tunnels started *by pyngrok*, but not agents started manually or by Streamlit.
print("Attempting to kill pyngrok tunnels...")
ngrok.kill()
print("pyngrok tunnels killed.")

# Stop all ngrok processes explicitly using pkill -f
# This is crucial to ensure no old ngrok agents are running from any source.
# -f is used to force kill if necessary and search based on full command line.
print("Attempting to kill all ngrok processes forcefully...")
# Use get_ipython().system() for reliable shell command execution in Colab
get_ipython().system('pkill -f ngrok')

# Give ample time for processes to terminate after killing
# Increased sleep time for robustness.
print("Waiting for ngrok processes to terminate...")
time.sleep(20) # Increased sleep time significantly

print("Checking if ngrok processes are still running...")
# Check for running ngrok processes (should ideally show nothing).
# !pgrep ngrok will print PIDs if any are found.
get_ipython().system('pgrep ngrok')


# Ensure the log file is cleared or doesn't contain previous runs
log_file_path = '/content/log.txt'
if os.path.exists(log_file_path):
    os.remove(log_file_path)
    print(f"Cleared log file: {log_file_path}")
else:
    print(f"Log file not found: {log_file_path}")


# Start Streamlit in the background using nohup and redirect output.
# Streamlit might start its own ngrok agent if it detects an internet connection.
print("Starting Streamlit...")
streamlit_command = f'nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &> {log_file_path} &'

# Use get_ipython().system() for running shell commands reliably in Colab.
# This command just *starts* the process, it doesn't wait for it.
streamlit_process_status = get_ipython().system(streamlit_command)
print(f"Streamlit command executed: {streamlit_command}")
# 0 usually means command was sent successfully, check log file for Streamlit errors


# Give Streamlit and its potential ngrok agent time to initialize.
# This sleep is CRUCIAL. Streamlit needs time to start and potentially
# launch its own ngrok agent before pyngrok can connect to it.
# Increased sleep time significantly for more complex apps/environments.
print("Waiting for Streamlit and ngrok agent to start...")
time.sleep(30) # Further increased sleep time - adjust if needed

# Create public tunnel by *connecting* to the ngrok agent that Streamlit started.
# pyngrok.connect() will attempt to connect to the ngrok agent running on
# the machine (which should be the one started by Streamlit/nohup).
try:
    print("Attempting to connect to ngrok tunnel...")
    # Connect to the standard ngrok agent API port (default is 4040),
    # or instruct the existing agent to open a tunnel to port 8501.
    # ngrok.connect(8501) tells the *existing* agent to open a tunnel to local port 8501.
    url = ngrok.connect(8501) # Specify the local port Streamlit is using
    print("üåê Dashboard URL:", url)
except Exception as e:
    # If connection fails, print the error and check the log file.
    # The log file should contain output from the Streamlit process, including
    # potential errors from Streamlit itself or its attempt to start ngrok.
    print(f"Error connecting ngrok: {e}")
    print("\nChecking log file for Streamlit or ngrok agent errors:")
    if os.path.exists(log_file_path):
        with open(log_file_path, 'r') as f:
            print(f.read())
    else:
        print("Log file not found.")

print("\nScript finished.")

from google.colab import drive
from pyngrok import ngrok
import time
from IPython import get_ipython # Import get_ipython

drive.mount('/content/drive')
ngrok.kill()
# Replace "YOUR_AUTH_TOKEN" with your actual ngrok auth token
!ngrok config add-authtoken "YOUR_AUTH_TOKEN" # <--- Replace this

get_ipython().system('nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &>/content/log.txt &')
time.sleep(15)
url = ngrok.connect(8501)
print("üåê Dashboard URL:", url)

from google.colab import drive
from pyngrok import ngrok
import time
from IPython import get_ipython # Import get_ipython

# Mount Google Drive
drive.mount('/content/drive')

# Kill any existing tunnels
ngrok.kill()

# üîë Add your correct Ngrok token here (PASTE IT CLEANLY)
# !!! REPLACE "YOUR_AUTH_TOKEN" with your actual token from the ngrok dashboard !!!
!ngrok config add-authtoken "PASTE_YOUR_REAL_TOKEN_HERE" # Replace this line with your actual token

# Launch Streamlit app in the background using nohup and redirect output
get_ipython().system('nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &>/content/log.txt &')

# Wait a bit for the server to start
# Increased sleep time for more robustness, especially in Colab
time.sleep(20) # Adjust if needed based on observation

# Connect ngrok tunnel to the Streamlit port (8501)
try:
    url = ngrok.connect(8501)
    print("üåê Dashboard URL:", url)
except Exception as e:
    # If connection fails, print the error and check the log file
    print(f"Error connecting ngrok: {e}")
    print("\nChecking log file for Streamlit or ngrok agent errors:")
    log_file_path = '/content/log.txt' # Define log_file_path here for access in exception
    if os.path.exists(log_file_path):
        with open(log_file_path, 'r') as f:
            print(f.read())
    else:
        print("Log file not found.")

from google.colab import drive
from pyngrok import ngrok
import time
from IPython import get_ipython # Import get_ipython

drive.mount('/content/drive')
ngrok.kill()
# Replace "YOUR_AUTH_TOKEN" with your actual ngrok auth token
!ngrok config add-authtoken "2ygLGeaxapWfrJZC0rS70Ev35Om_tcQv9zLBuakfsm1AmHrN" # Replace with your actual token

get_ipython().system('nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &>/content/log.txt &')
time.sleep(15)
try:
    url = ngrok.connect(8501)
    print("üåê Dashboard URL:", url)
except Exception as e:
    print(f"Error connecting ngrok: {e}")
    # Optional: Print log file content for debugging if connection fails
    # print("\nLog file content:")
    # !cat /content/log.txt

from google.colab import drive
from pyngrok import ngrok
import time

# Re-mount Google Drive
drive.mount('/content/drive')

# Kill old tunnels
ngrok.kill()

# üîë Add your correct Ngrok token here (PASTE IT CLEANLY)
!ngrok config add-authtoken "PASTE_YOUR_REAL_TOKEN_HERE"

# Start Streamlit in background
get_ipython().system('nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &>/content/log.txt &')
time.sleep(15)

# Start public tunnel
url = ngrok.connect(8501)
print("üåê Dashboard URL:", url)

from google.colab import drive
from pyngrok import ngrok
import time
from IPython import get_ipython

# Re-mount Google Drive
drive.mount('/content/drive')

# Kill old tunnels
ngrok.kill()

# üîë Add your correct Ngrok token here (PASTE IT CLEANLY)
# !!! REPLACE "PASTE_YOUR_REAL_TOKEN_HERE" with your actual token from the ngrok dashboard !!!
# Example: !ngrok config add-authtoken "2ygLGeaxapWfrJZC0rS70Ev35Om_tcQv9zLBuakfsm1AmHrN" # Use your actual token here
!ngrok config add-authtoken "YOUR_ACTUAL_NGROK_TOKEN_HERE" # <--- Replace this with your real token

# Start Streamlit in background
get_ipython().system('nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &>/content/log.txt &')
time.sleep(15)

# Start public tunnel
# This should now succeed if the token is valid and Streamlit started correctly
try:
    url = ngrok.connect(8501)
    print("üåê Dashboard URL:", url)
except Exception as e:
    print(f"Error connecting ngrok: {e}")
    print("\nChecking log file for Streamlit errors:")
    log_file_path = '/content/log.txt'
    if os.path.exists(log_file_path):
        with open(log_file_path, 'r') as f:
            print(f.read())
    else:
        print("Log file not found.")

from google.colab import drive
from pyngrok import ngrok
import time

# Re-mount Google Drive
drive.mount('/content/drive')

# Kill old tunnels
ngrok.kill()

# üîë Add your correct Ngrok token here (PASTE IT CLEANLY)
!ngrok config add-authtoken "2ygLGeaxapWfrJZC0rS70Ev35Om_tcQv9zLBuakfsm1AmHrN"

# Start Streamlit in background
get_ipython().system('nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &>/content/log.txt &')
time.sleep(15)

# Start public tunnel
url = ngrok.connect(8501)
print("üåê Dashboard URL:", url)

from pyngrok import ngrok
ngrok.kill()
!streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &>/content/log.txt &
import time
time.sleep(15)
url = ngrok.connect(8501)
print("üåê Dashboard URL:", url)

from pyngrok import ngrok
ngrok.kill()
!streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &>/content/log.txt &
import time
time.sleep(15)
url = ngrok.connect(8501)
print("üåê Dashboard URL:", url)

from google.colab import drive
from pyngrok import ngrok
import time
from IPython import get_ipython

# Mount Google Drive
drive.mount('/content/drive')

# Kill any existing tunnels
ngrok.kill()

# (Optional) Reconfigure ngrok authtoken if needed
# ngrok.set_auth_token("your_real_token")  ‚Üê Only needed once

# Launch Streamlit app
get_ipython().system('nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &>/content/log.txt &')

# Wait a bit for the server to start
time.sleep(15)

# Connect ngrok tunnel
url = ngrok.connect(8501)
print("üåê Dashboard URL:", url)

from google.colab import drive
from pyngrok import ngrok
import time
from IPython import get_ipython

# Mount Google Drive
drive.mount('/content/drive')

# Kill any existing tunnels
ngrok.kill()

# (Optional) Reconfigure ngrok authtoken if needed
# ngrok.set_auth_token("your_real_token")  ‚Üê Only needed once

# Launch Streamlit app
get_ipython().system('nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &>/content/log.txt &')

# Wait a bit for the server to start
time.sleep(15)

# Connect ngrok tunnel
url = ngrok.connect(8501)
print("üåê Dashboard URL:", url)

from google.colab import drive
from pyngrok import ngrok
import time
from IPython import get_ipython

# Mount Google Drive
drive.mount('/content/drive', force_remount=True)

# Kill any previously running tunnels
ngrok.kill()

# OPTIONAL: Set your token again only if needed
# ngrok.set_auth_token("your_actual_token_here")

# Launch the Streamlit app
get_ipython().system('nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &>/content/log.txt &')

# Wait a few seconds for Streamlit to boot
time.sleep(15)

# Create a new public URL
url = ngrok.connect(8501)
print("üåê Open your Streamlit Dashboard here:", url)

from google.colab import drive
from pyngrok import ngrok
import time
from IPython import get_ipython

# Mount Google Drive
drive.mount('/content/drive', force_remount=True)

# Kill any previously running tunnels
ngrok.kill()

# Run Streamlit again
get_ipython().system('nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &>/content/log.txt &')

# Wait a bit
time.sleep(15)

# New public URL
url = ngrok.connect(8501)
print("üåê Open your Streamlit Dashboard here:", url)

from pyngrok import ngrok
import time
from IPython import get_ipython

# Kill any existing ngrok tunnels
ngrok.kill()

# Start Streamlit app
get_ipython().system('nohup streamlit run /content/drive/MyDrive/diabetes_dashboard/app.py &>/content/log.txt &')

# Wait for the app to launch
time.sleep(15)

# Create public URL
url = ngrok.connect(8501)
print("üåê Open your Streamlit dashboard here:", url)

